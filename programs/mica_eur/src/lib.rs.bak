use anchor_lang::prelude::*;
use anchor_spl::{
    token_2022::{
        self,
        spl_token_2022::{
            extension::{
                transfer_hook::{self, TransferHookAccount},
                default_account_state::DefaultAccountState,
                metadata_pointer::MetadataPointer,
                permanent_delegate::PermanentDelegate, 
                BaseStateWithExtensions,
            },
            state::{AccountState, Mint},
        },
        InitializeMint2,
    },
};
use anchor_lang::solana_program::program::invoke;
use std::convert::TryFrom;

// Include the KYC oracle module
pub mod kyc_oracle;
use kyc_oracle::*;

// Define the program ID
declare_id!("FqyFQg8TEaxKNGd5LqHRMBKfNVQHeiohorXRiu2dATZX");

// Error codes for the program
#[error_code]
pub enum MicaEuroError {
    #[msg("User is not KYC verified")]
    NotKycVerified,
    #[msg("Account is frozen")]
    AccountFrozen,
    #[msg("Operation not permitted")]
    OperationNotPermitted,
    #[msg("Reserve balance insufficient")]
    InsufficientReserve,
    #[msg("Data validation failed")]
    ValidationFailed,
}

#[program]
pub mod mica_eur {
    use super::*;

    // Initialize the MiCA Euro stablecoin mint
    pub fn initialize_euro_mint(
        ctx: Context<InitializeEuroMint>,
        whitepaper_hash: String,
    ) -> Result<()> {
        msg!("Initializing MiCA EUR Token-2022 mint");
        
        // Set up the mint with Token-2022 extensions
        let cpi_accounts = InitializeMint2 {
            mint: ctx.accounts.mint.to_account_info(),
            rent: ctx.accounts.rent.to_account_info(),
        };
        
        token_2022::initialize_mint2(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                cpi_accounts,
            ),
            9, // decimals
            ctx.accounts.issuer.key(), // mint authority
            Some(ctx.accounts.freeze_authority.key()), // freeze authority
            Some(ctx.accounts.permanent_delegate.key()), // permanent delegate for MiCA compliance
        )?;

        // Store the euro mint details
        let mint_info = &mut ctx.accounts.mint_info;
        mint_info.authority = ctx.accounts.issuer.key();
        mint_info.freeze_authority = ctx.accounts.freeze_authority.key();
        mint_info.permanent_delegate = ctx.accounts.permanent_delegate.key();
        mint_info.whitepaper_hash = whitepaper_hash;
        mint_info.is_paused = false;
        mint_info.reserve_merkle_root = [0; 32]; // Initialize empty
        
        msg!("MiCA EUR token initialized successfully");
        
        Ok(())
    }

    // Mint tokens (only callable by the mint authority)
    pub fn mint_tokens(
        ctx: Context<MintTokens>,
        amount: u64,
        recipient_kyc_id: String,
    ) -> Result<()> {
        require!(!ctx.accounts.mint_info.is_paused, MicaEuroError::OperationNotPermitted);
        
        // Verify KYC status (would connect to KYC oracle in production)
        // This is a simplified version for the hackathon
        msg!("Minting {} tokens to recipient with KYC ID: {}", amount, recipient_kyc_id);
        
        // Check if recipient has proper KYC verification
        if let Some(kyc_user) = &ctx.accounts.kyc_user {
            require!(
                is_kyc_verified(kyc_user),
                MicaEuroError::NotKycVerified
            );
        } else {
            // In production, we'd enforce this check
            msg!("Warning: KYC user not provided, skipping validation for hackathon demo");
        }
        
        // Mint the tokens to the recipient
        let cpi_accounts = token_2022::MintTo {
            mint: ctx.accounts.mint.to_account_info(),
            to: ctx.accounts.recipient.to_account_info(),
            authority: ctx.accounts.issuer.to_account_info(),
        };
        
        token_2022::mint_to(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                cpi_accounts,
            ),
            amount,
        )?;
        
        msg!("Tokens minted successfully");
        
        Ok(())
    }

    // Update the reserve proof (daily merkle root)
    pub fn update_reserve_proof(
        ctx: Context<UpdateReserve>,
        merkle_root: [u8; 32],
    ) -> Result<()> {
        msg!("Updating reserve proof");
        
        // Update the merkle root in the mint info account
        let mint_info = &mut ctx.accounts.mint_info;
        mint_info.reserve_merkle_root = merkle_root;
        
        msg!("Reserve proof updated successfully");
        
        Ok(())
    }

    // Freeze account (for compliance actions)
    pub fn freeze_account(ctx: Context<ComplianceAction>) -> Result<()> {
        msg!("Freezing account for compliance action");
        
        let cpi_accounts = token_2022::FreezeAccount {
            account: ctx.accounts.target_account.to_account_info(),
            mint: ctx.accounts.mint.to_account_info(),
            authority: ctx.accounts.freeze_authority.to_account_info(),
        };
        
        token_2022::freeze_account(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                cpi_accounts,
            ),
        )?;
        
        msg!("Account frozen successfully");
        
        Ok(())
    }

    // Thaw account (unfreeze after compliance resolution)
    pub fn thaw_account(ctx: Context<ComplianceAction>) -> Result<()> {
        msg!("Thawing account after compliance resolution");
        
        let cpi_accounts = token_2022::ThawAccount {
            account: ctx.accounts.target_account.to_account_info(),
            mint: ctx.accounts.mint.to_account_info(),
            authority: ctx.accounts.freeze_authority.to_account_info(),
        };
        
        token_2022::thaw_account(
            CpiContext::new(
                ctx.accounts.token_program.to_account_info(),
                cpi_accounts,
            ),
        )?;
        
        msg!("Account thawed successfully");
        
        Ok(())
    }

    // Pause minting (emergency control)
    pub fn pause_mint(ctx: Context<PauseMint>, pause: bool) -> Result<()> {
        let mint_info = &mut ctx.accounts.mint_info;
        mint_info.is_paused = pause;
        
        msg!("Mint paused state set to: {}", pause);
        
        Ok(())
    }
    
    // KYC TransferHook implementation (simplified for hackathon)
    pub fn validate_transfer(
        ctx: Context<ValidateTransfer>,
        _amount: u64,
    ) -> Result<()> {
        msg!("Validating transfer with KYC check");
        
        // In a real implementation, this would check against an on-chain KYC oracle
        // For the hackathon demo, we'll verify if the KYC accounts are provided
        if let (Some(from_kyc), Some(to_kyc)) = (&ctx.accounts.from_kyc, &ctx.accounts.to_kyc) {
            // Verify both sender and receiver are KYC verified
            require!(
                is_kyc_verified(from_kyc),
                MicaEuroError::NotKycVerified
            );
            
            require!(
                is_kyc_verified(to_kyc),
                MicaEuroError::NotKycVerified
            );
            
            // Additional MiCA compliance checks could be added here
            // For example, checking transaction limits, etc.
        } else {
            // In production, we'd fail here
            msg!("Warning: KYC check bypassed for hackathon demo - would fail in production");
        }
        
        Ok(())
    }
    
    // KYC Oracle implementation
    pub fn initialize_kyc_oracle(ctx: Context<InitializeKycOracle>) -> Result<()> {
        kyc_oracle::initialize_kyc_oracle(ctx)
    }
    
    pub fn register_kyc_user(
        ctx: Context<RegisterKycUser>,
        blz: String,
        iban_hash: [u8; 32],
        country_code: String,
        verification_provider: String,
    ) -> Result<()> {
        kyc_oracle::register_kyc_user(ctx, blz, iban_hash, country_code, verification_provider)
    }
    
    pub fn update_kyc_status(
        ctx: Context<UpdateKycStatus>,
        status: KycStatus,
        verification_level: u8,
        expiry_days: i64,
    ) -> Result<()> {
        kyc_oracle::update_kyc_status(ctx, status, verification_level, expiry_days)
    }
}

// Account structure for mint information
#[account]
pub struct MicaEuroMintInfo {
    pub authority: Pubkey,
    pub freeze_authority: Pubkey,
    pub permanent_delegate: Pubkey,
    pub whitepaper_hash: String,
    pub is_paused: bool,
    pub reserve_merkle_root: [u8; 32],
}

// Context for initializing the euro mint
#[derive(Accounts)]
pub struct InitializeEuroMint<'info> {
    #[account(mut)]
    pub issuer: Signer<'info>,
    
    #[account(
        init,
        payer = issuer,
        space = 8 + std::mem::size_of::<MicaEuroMintInfo>() + 200, // Extra space for whitepaper hash
    )]
    pub mint_info: Account<'info, MicaEuroMintInfo>,
    
    /// CHECK: This is the mint account that will be initialized via CPI
    #[account(mut)]
    pub mint: UncheckedAccount<'info>,
    
    /// CHECK: This is the freeze authority
    pub freeze_authority: UncheckedAccount<'info>,
    
    /// CHECK: This is the permanent delegate for regulatory compliance
    pub permanent_delegate: UncheckedAccount<'info>,
    
    pub system_program: Program<'info, System>,
    pub token_program: Program<'info, token_2022::Token2022>,
    pub rent: Sysvar<'info, Rent>,
}

// Context for minting tokens
#[derive(Accounts)]
pub struct MintTokens<'info> {
    #[account(mut)]
    pub issuer: Signer<'info>,
    
    #[account(
        mut,
        constraint = mint_info.authority == issuer.key()
    )]
    pub mint_info: Account<'info, MicaEuroMintInfo>,
    
    #[account(mut)]
    pub mint: Account<'info, token_2022::Mint>,
    
    /// CHECK: This is the token account to mint to
    #[account(mut)]
    pub recipient: UncheckedAccount<'info>,
    
    /// Optional: KYC user account for the recipient
    pub kyc_user: Option<Account<'info, KycUser>>,
    
    pub token_program: Program<'info, token_2022::Token2022>,
}

// Context for updating reserve proof
#[derive(Accounts)]
pub struct UpdateReserve<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    
    #[account(
        mut,
        constraint = mint_info.authority == authority.key()
    )]
    pub mint_info: Account<'info, MicaEuroMintInfo>,
}

// Context for compliance actions (freeze/thaw)
#[derive(Accounts)]
pub struct ComplianceAction<'info> {
    #[account(mut)]
    pub freeze_authority: Signer<'info>,
    
    #[account(
        constraint = mint_info.freeze_authority == freeze_authority.key()
    )]
    pub mint_info: Account<'info, MicaEuroMintInfo>,
    
    #[account(mut)]
    pub mint: Account<'info, token_2022::Mint>,
    
    /// CHECK: This is the token account to freeze/thaw
    #[account(mut)]
    pub target_account: UncheckedAccount<'info>,
    
    pub token_program: Program<'info, token_2022::Token2022>,
}

// Context for pausing mint operations
#[derive(Accounts)]
pub struct PauseMint<'info> {
    #[account(mut)]
    pub authority: Signer<'info>,
    
    #[account(
        mut,
        constraint = mint_info.authority == authority.key() || 
                    mint_info.freeze_authority == authority.key()
    )]
    pub mint_info: Account<'info, MicaEuroMintInfo>,
}

// Context for KYC TransferHook validation
#[derive(Accounts)]
pub struct ValidateTransfer<'info> {
    pub mint: Account<'info, token_2022::Mint>,
    
    /// CHECK: Transfer hook accounts
    #[account(
        constraint = from.owner == token_program.key()
    )]
    pub from: UncheckedAccount<'info>,
    
    /// CHECK: Transfer hook accounts
    #[account(
        constraint = to.owner == token_program.key()
    )]
    pub to: UncheckedAccount<'info>,
    
    /// Optional: KYC user account for the sender
    pub from_kyc: Option<Account<'info, KycUser>>,
    
    /// Optional: KYC user account for the receiver
    pub to_kyc: Option<Account<'info, KycUser>>,
    
    pub token_program: Program<'info, token_2022::Token2022>,
}

// Add unit tests for internal functions
#[cfg(test)]
mod tests {
    use super::*;
    use kyc_oracle::{KycUser, KycStatus};
    use solana_program_test::*;
    
    // Test KYC verification logic
    #[test]
    fn test_kyc_is_verified() {
        let mut kyc_user = KycUser {
            authority: Pubkey::new_unique(),
            user: Pubkey::new_unique(),
            status: KycStatus::Verified,
            blz: "10070000".to_string(),
            iban_hash: [0; 32],
            verification_date: 0,
            expiry_date: i64::MAX, // Far future
            verification_level: 2,
            country_code: "DE".to_string(),
            verification_provider: "TEST".to_string(),
        };
        
        // Verified user with unexpired verification should return true
        assert!(kyc_oracle::is_kyc_verified(&kyc_user));
        
        // Unverified user should return false
        kyc_user.status = KycStatus::Unverified;
        assert!(!kyc_oracle::is_kyc_verified(&kyc_user));
        
        // Pending user should return false
        kyc_user.status = KycStatus::Pending;
        assert!(!kyc_oracle::is_kyc_verified(&kyc_user));
        
        // Rejected user should return false
        kyc_user.status = KycStatus::Rejected;
        assert!(!kyc_oracle::is_kyc_verified(&kyc_user));
        
        // Verified but expired should return false
        kyc_user.status = KycStatus::Verified;
        kyc_user.expiry_date = 0; // Long past
        assert!(!kyc_oracle::is_kyc_verified(&kyc_user));
        
        // Verified but level 0 should return false
        kyc_user.expiry_date = i64::MAX; // Far future
        kyc_user.verification_level = 0;
        assert!(!kyc_oracle::is_kyc_verified(&kyc_user));
    }
    
    // Test MiCA compliance requirements check
    #[test]
    fn test_meets_mica_requirements() {
        let mut kyc_user = KycUser {
            authority: Pubkey::new_unique(),
            user: Pubkey::new_unique(),
            status: KycStatus::Verified,
            blz: "10070000".to_string(),
            iban_hash: [0; 32],
            verification_date: 0,
            expiry_date: i64::MAX, // Far future
            verification_level: 2,
            country_code: "DE".to_string(),
            verification_provider: "TEST".to_string(),
        };
        
        // User meets requirements (level 2, from Germany)
        assert!(kyc_oracle::meets_mica_requirements(&kyc_user, 2, &["DE", "FR", "IT"]));
        
        // User doesn't meet level requirements
        assert!(!kyc_oracle::meets_mica_requirements(&kyc_user, 3, &["DE", "FR", "IT"]));
        
        // User doesn't meet country requirements
        assert!(!kyc_oracle::meets_mica_requirements(&kyc_user, 2, &["FR", "IT"]));
        
        // User with level 1 meets level 1 requirements
        kyc_user.verification_level = 1;
        assert!(kyc_oracle::meets_mica_requirements(&kyc_user, 1, &["DE", "FR", "IT"]));
        
        // User from Austria meets requirements when Austria is allowed
        kyc_user.verification_level = 2;
        kyc_user.country_code = "AT".to_string();
        assert!(kyc_oracle::meets_mica_requirements(&kyc_user, 2, &["DE", "AT", "IT"]));
        
        // Unverified user doesn't meet requirements regardless of level/country
        kyc_user.status = KycStatus::Unverified;
        assert!(!kyc_oracle::meets_mica_requirements(&kyc_user, 2, &["DE", "AT", "IT"]));
    }
}
